#include "xbase.hpp"
#include <iomanip>
#include <iostream>
#include <string>
#include <vector>
#include <algorithm>
#include <sstream>

using xbase::DbArea;
using xbase::FieldDef;

namespace {

// Which types behave like “character” and should be left-padded to field length
inline bool is_char_like(char t) {
    switch (t) {
        case 'C': case 'c': // Character
        case 'M': case 'm': // Memo (printed as text stub)
            return true;
        default:
            return false;
    }
}

// Which types should be right-aligned (numbers, dates, logical)
inline bool is_right_aligned(char t) {
    switch (t) {
        case 'N': case 'n': // Numeric
        case 'F': case 'f': // Float
        case 'D': case 'd': // Date (YYYYMMDD)
        case 'L': case 'l': // Logical
            return true;
        default:
            return false;
    }
}

// Display width for a field (not less than header width)
inline int data_width_for(const FieldDef& f) {
    switch (f.type) {
        case 'C': case 'c': case 'M': case 'm':
            return std::max<int>(1, static_cast<int>(f.length));
        case 'D': case 'd':
            return 8; // "YYYYMMDD"
        case 'L': case 'l':
            return 1; // T/F
        case 'N': case 'n': case 'F': case 'f':
        default:
            // For numeric, DBF length already accounts for digits, sign, and dot
            return std::max<int>(1, static_cast<int>(f.length));
    }
}

// Trim right spaces from a string
inline std::string rtrim(std::string s) {
    while (!s.empty() && s.back() == ' ') s.pop_back();
    return s;
}

// Pad/truncate to exactly w characters; left for numbers, right for text
inline std::string fit_cell(std::string s, int w, bool right_align, bool pad_text_to_width)
{
    if (!pad_text_to_width) {
        // For non-char fields we don't pad with spaces beyond alignment; just align with setw later.
        if (static_cast<int>(s.size()) > w) s.resize(static_cast<std::size_t>(w));
        return s;
    }

    // For character-like: pad to width so columns look like a sheet
    if (static_cast<int>(s.size()) > w) s.resize(static_cast<std::size_t>(w));
    if (static_cast<int>(s.size()) < w) {
        if (right_align) {
            return std::string(static_cast<std::size_t>(w - s.size()), ' ') + s;
        } else {
            return s + std::string(static_cast<std::size_t>(w - s.size()), ' ');
        }
    }
    return s;
}

} // namespace

// LIST
// Prints a page of rows (default 20) with an aligned header.
// Character fields are space-padded to their fixed DBF length to create even columns.
void cmd_LIST(DbArea& area, std::istringstream& iss)
{
    const auto& defs = area.fields();
    const int   ncol = area.fieldCount();
    if (ncol <= 0) {
        std::cout << "(No fields)\n";
        return;
    }

    // How many rows
    int limit = 20; // safe default page size
    if (iss.good()) {
        int maybe;
        if (iss >> maybe && maybe > 0) limit = maybe;
    }

    const int total = static_cast<int>(area.recCount());
    limit = std::min(limit, total);

    // Column widths: max(header, data width)
    std::vector<int> widths;
    widths.reserve(static_cast<std::size_t>(ncol));
    for (int i = 0; i < ncol; ++i) {
        const FieldDef& f = defs[static_cast<std::size_t>(i)];
        const int w = std::max<int>(static_cast<int>(f.name.size()), data_width_for(f));
        widths.push_back(w);
    }

    // HEADER
    for (int i = 0; i < ncol; ++i) {
        const FieldDef& f = defs[static_cast<std::size_t>(i)];
        const bool right = is_right_aligned(f.type);
        if (right) {
            std::cout << std::right << std::setw(static_cast<int>(widths[static_cast<std::size_t>(i)]));
        } else {
            std::cout << std::left  << std::setw(static_cast<int>(widths[static_cast<std::size_t>(i)]));
        }
        std::cout << f.name;
        if (i != ncol - 1) std::cout << ' ';
    }
    std::cout << "\n";

    // RULER
    for (int i = 0; i < ncol; ++i) {
        for (int k = 0; k < widths[static_cast<std::size_t>(i)]; ++k) std::cout << '-';
        if (i != ncol - 1) std::cout << ' ';
    }
    std::cout << "\n";

    if (limit == 0) return;

    // Start at first record
    if (!area.gotoRec(1) || !area.readCurrent()) {
        std::cout << "(No records)\n";
        return;
    }

    // ROWS
    for (int r = 0; r < limit; ++r) {
        for (int c = 0; c < ncol; ++c) {
            const FieldDef& f = defs[static_cast<std::size_t>(c)];
            const bool right = is_right_aligned(f.type);
            const bool pad_text = is_char_like(f.type);

            std::string cell = area.get(c + 1);              // 1-based field index
            if (pad_text) cell = rtrim(cell);                // trim stored right padding; we’ll re-pad

            cell = fit_cell(cell, widths[static_cast<std::size_t>(c)], right, pad_text);

            if (right) {
                std::cout << std::right << std::setw(widths[static_cast<std::size_t>(c)]) << cell;
            } else {
                // For already padded text cells, setw still works but won’t add extra spaces.
                std::cout << std::left  << std::setw(widths[static_cast<std::size_t>(c)]) << cell;
            }
            if (c != ncol - 1) std::cout << ' ';
        }
        std::cout << "\n";

        if (r + 1 == limit) break;
        if (!area.skip(1)) break;
        if (!area.readCurrent()) break;
    }

    // Reset stream flags for safety in case caller reuses iss
    iss.clear();
}
