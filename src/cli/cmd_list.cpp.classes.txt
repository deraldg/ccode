// src/cli/cmd_list.cpp
#include <sstream>
#include <string>
#include <vector>
#include <iostream>
#include <iomanip>
#include <type_traits>
#include <algorithm>

#include "xbase.hpp"
#include "textio.hpp"

using xbase::DbArea;

// ---------- tiny detection helpers (no RTTI, no macros) ----------
template <class T, class = void> struct has_len     : std::false_type {};
template <class T> struct has_len<T,     std::void_t<decltype(std::declval<const T&>().len)>>     : std::true_type {};
template <class T, class = void> struct has_width   : std::false_type {};
template <class T> struct has_width<T,   std::void_t<decltype(std::declval<const T&>().width)>>   : std::true_type {};
template <class T, class = void> struct has_length  : std::false_type {};
template <class T> struct has_length<T,  std::void_t<decltype(std::declval<const T&>().length)>>  : std::true_type {};
template <class T, class = void> struct has_type    : std::false_type {};
template <class T> struct has_type<T,    std::void_t<decltype(std::declval<const T&>().type)>>    : std::true_type {};

template <class A, class = void> struct has_defs    : std::false_type {};
template <class A> struct has_defs<A,    std::void_t<decltype(std::declval<const A&>().defs())>>  : std::true_type {};

template <class A, class = void> struct has_size    : std::false_type {};
template <class A> struct has_size<A,    std::void_t<decltype(std::declval<const A&>().size())>>  : std::true_type {};
template <class A, class = void> struct has_count   : std::false_type {};
template <class A> struct has_count<A,   std::void_t<decltype(std::declval<const A&>().count())>> : std::true_type {};
template <class A, class = void> struct has_records : std::false_type {};
template <class A> struct has_records<A, std::void_t<decltype(std::declval<const A&>().records())>>: std::true_type {};
template <class A, class = void> struct has_nrecs   : std::false_type {};
template <class A> struct has_nrecs<A,   std::void_t<decltype(std::declval<const A&>().nrecs())>> : std::true_type {};

// Optional helpers to pull a cell as string (we try several common shapes)
template <class A, class = void> struct has_get_string : std::false_type {};
template <class A> struct has_get_string<A, std::void_t<decltype(std::declval<const A&>().get_string(size_t{}, size_t{}))>> : std::true_type {};

template <class A, class = void> struct has_row_get_string : std::false_type {};
template <class A>
struct has_row_get_string<A, std::void_t<
    decltype(std::declval<const A&>().row(size_t{}).get_string(size_t{}))
>> : std::true_type {};

template <class A, class = void> struct has_value_to_string : std::false_type {};
template <class A>
struct has_value_to_string<A, std::void_t<
    decltype(std::declval<const A&>().value(size_t{}, size_t{}).to_string())
>> : std::true_type {};

// ---------- tiny adapters ----------
template <class A>
static size_t rec_count(const A& a) {
    if constexpr (has_size<A>::value)    return static_cast<size_t>(a.size());
    else if constexpr (has_count<A>::value)   return static_cast<size_t>(a.count());
    else if constexpr (has_records<A>::value) return static_cast<size_t>(a.records());
    else if constexpr (has_nrecs<A>::value)   return static_cast<size_t>(a.nrecs());
    else return 0;
}

template <class FD>
static int field_width(const FD& fd, size_t fallback) {
    if constexpr (has_len<FD>::value)     return std::max<int>(static_cast<int>(fallback), static_cast<int>(fd.len));
    else if constexpr (has_width<FD>::value)   return std::max<int>(static_cast<int>(fallback), static_cast<int>(fd.width));
    else if constexpr (has_length<FD>::value)  return std::max<int>(static_cast<int>(fallback), static_cast<int>(fd.length));
    else return static_cast<int>(fallback);
}

// very light heuristic: consider CHAR-like if type is a char and equals 'C' (or not numeric at all)
template <class FD>
static bool is_char_like(const FD& fd) {
    if constexpr (has_type<FD>::value) {
        using T = std::decay_t<decltype(fd.type)>;
        if constexpr (std::is_same_v<T, char>) {
            return fd.type == 'C' || fd.type == 'M' || fd.type == 'D' || fd.type == 'L'; // treat non-pure numeric as left padded
        }
        // If it's an enum or other, default to left-justify for safety.
        return true;
    } else {
        return true; // when in doubt, left-justify/pad like text
    }
}

template <class A>
static std::string cell_as_string(const A& a, size_t rec, size_t col) {
    if constexpr (has_get_string<A>::value) {
        return a.get_string(rec, col);
    } else if constexpr (has_row_get_string<A>::value) {
        return a.row(rec).get_string(col);
    } else if constexpr (has_value_to_string<A>::value) {
        return a.value(rec, col).to_string();
    } else {
        // Last-resort stub to keep compile going if API differs;
        // it keeps output deterministic rather than failing to build.
        return std::string{};
    }
}

// ---------- command ----------
void cmd_LIST(DbArea& area, std::istringstream& iss) {
    // figure out how many lines to show (optional integer argument)
    size_t max_lines = 0;
    {
        long n;
        if (iss >> n && n > 0) max_lines = static_cast<size_t>(n);
    }

    // pull field defs
    if constexpr (!has_defs<DbArea>::value) {
        std::cout << "(LIST) no field metadata available.\n";
        return;
    }

    const auto& defs = area.defs();
    const size_t ncols = defs.size();

    // compute display widths per column
    std::vector<int> widths;
    widths.reserve(ncols);
    for (size_t i = 0; i < ncols; ++i) {
        const auto& fd = defs[i];
        const size_t namew = fd.name.size();
        // prefer fixed field length from header when present
        int w = field_width(fd, namew);
        // keep a sane minimum so headers never get squashed
        w = std::max<int>(w, static_cast<int>(namew));
        widths.push_back(w);
    }

    // HEADER
    for (size_t i = 0; i < ncols; ++i) {
        std::cout << std::left << std::setw(widths[i]) << defs[i].name;
        if (i + 1 < ncols) std::cout << ' ';
    }
    std::cout << "\n";

    // separator line
    for (size_t i = 0; i < ncols; ++i) {
        std::cout << std::setw(widths[i]) << std::setfill('-') << "" << std::setfill(' ');
        if (i + 1 < ncols) std::cout << ' ';
    }
    std::cout << "\n";

    // ROWS
    const size_t total = rec_count(area);
    size_t shown = 0;
    const size_t to_show = (max_lines == 0) ? total : std::min(max_lines, total);

    for (size_t r = 0; r < to_show; ++r) {
        for (size_t c = 0; c < ncols; ++c) {
            std::string s = cell_as_string(area, r, c);

            // pad character/text fields to fixed width; other types just use setw without extra trimming
            if (is_char_like(defs[c])) {
                if (s.size() > static_cast<size_t>(widths[c])) {
                    // truncate visually (DBF typically stores fixed length anyway)
                    s.resize(static_cast<size_t>(widths[c]));
                }
                std::cout << std::left << std::setw(widths[c]) << s;
            } else {
                // numbers/dates/etc.: leave as-is; setw gives alignment without adding trailing spaces
                std::cout << std::right << std::setw(widths[c]) << s;
            }

            if (c + 1 < ncols) std::cout << ' ';
        }
        std::cout << "\n";
        ++shown;
    }

    // footer (simple)
    std::cout << "[Listed " << shown << " of " << total << " record(s)]\n";
}
